<!-- Source: https://github.com/casualwriter/vanilla-chatgpt -->
<!DOCTYPE html>
<head>
  <title>Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>

<style>
body  { font-family: Roboto,Lato,Arial; line-height:1.5; font-size:16px; margin:0; padding:0; overflow:hidden; }
header { background-color: rgb(31 41 55); }
header { color:#eee; padding:12px; font-size:30px; height:45px; font-family:"Open Sans" }
#left  { float:left;  width:calc(60vw - 30px); height:calc(100vh - 100px); }
#right { float:right; width:40%; height:calc(100vh - 100px); } 
#left, #prompt, #list { border:1px solid grey; }
#left, #prompt, #list{ padding:6px; overflow:auto; }
#list li:hover  { background:#ddd }
#menu button    { font-family:Lato,arial; border-radius:3px; border:none; padding:3px 6px}
#right textarea, #controls { display:block; width:96%; margin:3px auto;}
#right textarea { background:#eee; box-sizing: border-box; }
#controls { text-align:right; padding:5px 6px; border: 1px solid #fff; }
#controls button { height: 28px; vertical-align: middle; }
#message { float: left; }
#mail, #title { padding:12px; max-width:960px; }
.prompt { color:#322; background:#ccc; padding:6px; }

.markdown code { background:#f0f0f0; color:navy; border-radius:6px; padding:2px; } 
.markdown pre  { background:#f0f0f0; margin:16px; border:1px solid #ddd; padding:8px; border-radius: 6px;  } 
.markdown pre:hover button { display:block; }
.markdown pre button { display:none; float:right; margin:4px }
.markdown blockquote { background:#f0f0f0; border-left:6px solid grey; padding:8px }
.markdown table { margin:12px; border-collapse: collapse; }
.markdown th    { border:1px solid grey; background:lightgrey; padding:6px; } 
.markdown td    { border:1px solid grey;  padding:6px; }
.markdown tr:nth-child(even) {  background:#f0f0f0;  }

@media print{
  #menu, #right { display:none!important }
  #left { position:relative; width:100%; left:0px; top:0px; border:none; height:auto; overflow:hidden }
  .prompt { border-bottom: 1px solid grey }
}

@media screen and (max-width: 880px) {
  #list, .desktop { display:none!important }
  #right { position:absolute; width:auto; height:auto; bottom:10px; left:8px; right:70px }
  #right textarea { height:3.2em; padding:10px; overflow:auto }
  #left	 { width:97%; height:calc(100vh - 210px);  }
}
</style>

<header>
  <div id="heading" style="float:left">
    Chat example
  </div>
</header>

<div id="content" style="margin:8px;color:#112;background:bed">
  <div id="right">
    <textarea id="prompt" rows="10" placeholder="Please input prompt here..."></textarea>
    <div id="controls">
        <span id="message"><!-- will be filled with status messages --></span>
        <button onclick="chat.recognition()" title="voice input">ðŸŽ¤</button>
        <button id="btnSend" accesskey="s" onclick="chat.submit()">Send</button>
    </div>
  </div>
  <div id="left">
    <h3 id="title">
        Conversation history 
        <button onclick="chat.export()" title="export conversation">Export</button>
    </h3>
    <div id="main">
    <!-- conversation history will be displayed here -->
    </div>
  </div>
</div>

<script type="text/javascript">

const chat = (id) => window.document.getElementById(id);

// Set the API endpoint URL
chat.endPoint  = "/chat";
chat.model = "gpt-3.5-turbo"
chat.body  = { /*model: chat.model, temperature: 0.8*/ }
chat.history = []

// stream result from openai
chat.stream = function (prompt) {

  //chat.body.stream = true 
  chat.body.messages = [ { role: "user", content: prompt} ];
  chat.result = '';
  chat.controller = new AbortController();
  const signal = chat.controller.signal;
   
  // if there is history, add the last 5 messages to the chat body
  for (let i=chat.history.length-1; i>=0 && i > (chat.history.length - 5); i--) {
    chat.body.messages.unshift( { role:'assistant', content: chat.history[i].result } );
    chat.body.messages.unshift( { role:'user', content: chat.history[i].prompt } );
  }
  
  fetch( chat.endPoint, {
    method:'POST',
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(chat.body),
    signal
  }).then( response => { 
  
    if (!response.ok) {
        if (response.status == 401) throw new Error('401 Unauthorized, invalide API Key');
        throw new Error('failed to get data, error status '+response.status)
    }

    // this is for non-streaming response
    response.json().then( jsonBody => {
        chat.result = (jsonBody.content || '');
        chat.oncomplete(chat.result);
        chat("message").innerHTML = 'Done.';
    }).catch( error => chat.onerror(error) );
    
    /*
    // this is for streaming response (not supported yet)
    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
    
    reader.read().then( function processText({ done, value }) {
    
      if (done) return chat.oncomplete(chat.result);
      
      const lines = (chat.value=value).split('\n');

      for (let i in lines) {
        if (lines[i].length === 0) continue;     // ignore empty message
        if (lines[i].startsWith(':')) continue;  // ignore comment message
        if (lines[i] === 'data: [DONE]') return chat.oncomplete(chat.result); // end of message
        
        chat.json = JSON.parse(lines[i].substring(6));
        if (chat.json.choices) {
          chat.result += (chat.json.choices[0].delta.content||'') 
        }	 
      }

      chat.onmessage(chat.result)
      return reader.read().then(processText);
       
    } )
      */
    
  } ).catch( error => chat.onerror(error) );
  
}

// default error handle
chat.onerror = (error) => { alert(error);  };

// export conversation
chat.export = (fname) => {
  if (!chat.history || chat.history.length === 0) {
    chat("message").innerHTML = 'No conversation to export!'
    return;
}
  const link = document.createElement('a');
  link.href = 'data:text/plain;charset=utf-8,' 
  chat.history.forEach( (x) => { 
    link.href += encodeURIComponent('### '+x.prompt+'\n\n'+x.result+'\n\n') 
  } );  
  link.download = fname||('chat-'+new Date().toISOString().substr(0,16))+'.md';
  link.click();
} 

//================= main program ===================

// show whole conversation when message completed
chat.oncomplete = (text) => {
  let html='';
  // chat("message").innerHTML = `(model: ${chat.model})`
  chat.history.push( { prompt: chat.prompt, result: chat.result } )
  
  for (let i=0; i < chat.history.length; i++) {
     html += '<h4 class="prompt" id="prompt'+i+'">'; 
     html += chat.history[i].prompt + '</h4><div class="result">' + chat.history[i].result + '</div>';
  }
  
  chat("main").innerHTML = html;
  chat("left").scrollTop = chat("left").scrollHeight;
  chat("btnSend").innerHTML = 'Send'
  
  chat('prompt').value = '';  
}

// abort fetch request.
chat.abort = () => { 
  chat.controller.abort()
  chat("receiving").innerHTML += '\n<font color=red>Message Aborted!</font>'
  chat("receiving").id = 'abort';
};

// submit prompt
chat.submit = () => {
  if (chat("btnSend").innerText === 'Stop..') {
    chat.abort()
    chat("btnSend").innerText = 'Send'
  } else {
    chat.prompt = chat('prompt').value.trim();
    if (chat.prompt === '') {
      chat("message").innerHTML = 'Please input prompt!'
      return;
    }
    chat.stream(chat.prompt);
    chat("message").innerHTML = 'Receiving messages...';
    //chat("main").innerHTML += '<h4 class="prompt">' + chat.prompt + '</h4>\n<div id="receiving">Receiving....</div>'
    chat("left").scrollTop = chat("left").scrollHeight;
    chat("btnSend").innerText = 'Stop..'
  }  
}

// prompt for API key if not found in localStorage
window.onload = () => {
  chat('prompt').focus();
}

// add submit hot-key of ctrl-enter
document.addEventListener('keydown', function(event) {
  if ( event.key==='Enter' && (chat.hotkey!='ctrl'||event.ctrlKey)) {
    if (chat("btnSend").innerText === 'Send') { 
      event.preventDefault(); chat.submit(); 
    }
  }  
});

// voice recognition
var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
chat.speech = new SpeechRecognition();

chat.speech.onresult = e => chat('prompt').value = e.results[0][0].transcript;

chat.recognition = () => {
  chat.speech.start()
  chat('prompt').value = 'Listening...'
}   
</script>